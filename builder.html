<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Create Token - TokenMaker</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-50 text-gray-800">
  <header class="bg-white shadow">
    <div class="max-w-5xl mx-auto px-4 py-4 flex items-center justify-between">
      <h1 class="text-2xl font-bold text-indigo-600"><a href="index.html">TokenMaker</a></h1>
      <nav>
        <a href="index.html" class="text-indigo-600 hover:text-indigo-800 font-medium">Home</a>
      </nav>
    </div>
  </header>

  <main class="max-w-3xl mx-auto px-4 py-16">
    <h2 class="text-3xl font-bold mb-4">Create your ERC-20 token</h2>
    <p class="text-gray-600 mb-8">Fill in the details below and deploy your token directly from your browser.</p>

    <div class="bg-white p-6 rounded-lg shadow">
      <div class="grid gap-4 md:grid-cols-2">
        <div>
          <label class="block text-gray-700 font-medium mb-1" for="tokenName">Token Name</label>
          <input type="text" id="tokenName" class="w-full border rounded px-3 py-2" placeholder="MyToken">
        </div>
        <div>
          <label class="block text-gray-700 font-medium mb-1" for="tokenSymbol">Symbol</label>
          <input type="text" id="tokenSymbol" class="w-full border rounded px-3 py-2" placeholder="MTK">
        </div>
        <div>
          <label class="block text-gray-700 font-medium mb-1" for="tokenSupply">Total Supply</label>
          <input type="number" id="tokenSupply" class="w-full border rounded px-3 py-2" placeholder="1000000">
        </div>
        <div>
          <label class="block text-gray-700 font-medium mb-1" for="decimals">Decimals</label>
          <input type="number" id="decimals" class="w-full border rounded px-3 py-2" placeholder="18" value="18">
        </div>
        <div>
          <label class="block text-gray-700 font-medium mb-1" for="network">Network</label>
          <select id="network" class="w-full border rounded px-3 py-2">
            <option value="80002">Polygon Amoy (Testnet)</option>
            <option value="11155111">Ethereum Sepolia</option>
            <option value="44787">Celo Alfajores</option>
          </select>
        </div>
      </div>
      <div class="mt-4 flex items-center">
        <input type="checkbox" id="mintable" class="mr-2">
        <label for="mintable" class="text-gray-700">Allow Minting (owner only)</label>
      </div>
      <div class="mt-2 flex items-center">
        <input type="checkbox" id="burnable" class="mr-2">
        <label for="burnable" class="text-gray-700">Allow Burning (owner only)</label>
      </div>
      <div class="mt-6">
        <button id="createBtn" class="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">Create Token</button>
      </div>
      <div id="status" class="mt-4 p-4 bg-gray-100 rounded text-sm overflow-auto" style="max-height: 300px;"></div>
      <div id="postDeploy" class="mt-6"></div>
    </div>
  </main>

  <footer class="bg-gray-100 py-6">
    <div class="max-w-5xl mx-auto px-4 text-center text-gray-500">
      © <span id="year"></span> TokenMaker. All rights reserved.
    </div>
  </footer>

  <!-- Load external libraries -->
  <!-- Ethers.js library for interacting with EVM networks. SRI attributes are omitted to prevent mismatch errors. -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- BrowserSolc for compiling Solidity in browser -->
      <!--
        Use a supported version of browser‑solc. The 0.6.1 release referenced previously
        doesn't exist on jsDelivr, which caused the global `BrowserSolc` object to be
        undefined at runtime. Version 1.0.0 is the latest available and exposes
        `BrowserSolc` on the `window` object once loaded. We reference the
        bundled `index.min.js` file here. See
        https://www.jsdelivr.com/package/npm/browser-solc for details.
      -->
      <script src="https://cdn.jsdelivr.net/npm/browser-solc@1.0.0/index.min.js"></script>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();

    const statusEl = document.getElementById('status');

    function logStatus(message) {
      const p = document.createElement('p');
      p.textContent = message;
      statusEl.appendChild(p);
      statusEl.scrollTop = statusEl.scrollHeight;
    }

    // Solidity source for customizable ERC-20 token
    /**
     * Build the Solidity source code for the CustomToken contract.
     *
     * @param {boolean} allowMinting Whether to include a mint function
     * @param {boolean} allowBurning Whether to include a burn function
     * @returns {string} Solidity source code
     */
    function getContractSource(allowMinting, allowBurning) {
      return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract CustomToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        owner = msg.sender;
        uint256 supplyWithDecimals = initialSupply * (10 ** uint256(decimals));
        totalSupply = supplyWithDecimals;
        balances[msg.sender] = supplyWithDecimals;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call");
        _;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        require(to != address(0), "Invalid address");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function allowance(address _owner, address spender) public view returns (uint256) {
        return allowances[_owner][spender];
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        require(to != address(0), "Invalid address");
        require(balances[from] >= amount, "Insufficient balance");
        require(allowances[from][msg.sender] >= amount, "Allowance exceeded");
        balances[from] -= amount;
        balances[to] += amount;
        allowances[from][msg.sender] -= amount;
        emit Transfer(from, to, amount);
        return true;
    }

${allowMinting ? '    /**\n     * Mint new tokens to a specified address.\n     * @param to Receiver of the minted tokens\n     * @param amount Number of whole tokens to mint (without decimals)\n     */\n    function mint(address to, uint256 amount) public onlyOwner {\n        require(to != address(0), "Invalid address");\n        uint256 amountWithDecimals = amount * (10 ** uint256(decimals));\n        totalSupply += amountWithDecimals;\n        balances[to] += amountWithDecimals;\n        emit Transfer(address(0), to, amountWithDecimals);\n    }\n' : ''}${allowBurning ? '    /**\n     * Burn tokens from a specified address.\n     * @param from Address whose tokens will be burned\n     * @param amount Number of whole tokens to burn (without decimals)\n     */\n    function burn(address from, uint256 amount) public onlyOwner {\n        require(from != address(0), "Invalid address");\n        uint256 amountWithDecimals = amount * (10 ** uint256(decimals));\n        require(balances[from] >= amountWithDecimals, "Insufficient balance to burn");\n        balances[from] -= amountWithDecimals;\n        totalSupply -= amountWithDecimals;\n        emit Transfer(from, address(0), amountWithDecimals);\n    }\n' : ''}
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}`;
    }

    async function compileContract(sourceCode) {
        return new Promise((resolve, reject) => {
            // If the BrowserSolc library hasn't loaded, reject early. This can happen if
            // the CDN fails to load or the script isn't included on the page.
            if (typeof BrowserSolc === 'undefined') {
              reject(new Error('Solidity compiler library (browser-solc) failed to load. Please refresh the page or check network connectivity.'));
              return;
            }
            BrowserSolc.getVersions(function(soljsonSources, soljsonVersions) {
              const version = soljsonVersions['0.8.20'];
              BrowserSolc.loadVersion(version, function(compiler) {
                const compiled = compiler.compile(sourceCode, 1);
                if (compiled && compiled.contracts && compiled.contracts[':CustomToken']) {
                  const contract = compiled.contracts[':CustomToken'];
                  resolve({ abi: JSON.parse(contract.interface), bytecode: contract.bytecode });
                } else {
                  reject(compiled);
                }
              });
            });
          });
    }

    async function createToken() {
      // Reset status and post-deploy content
      statusEl.innerHTML = '';
      document.getElementById('postDeploy').innerHTML = '';
      try {
        // Read input values
        const name = document.getElementById('tokenName').value.trim();
        const symbol = document.getElementById('tokenSymbol').value.trim();
        const supply = document.getElementById('tokenSupply').value.trim();
        const decimals = parseInt(document.getElementById('decimals').value.trim());
        const mintable = document.getElementById('mintable').checked;
        const burnable = document.getElementById('burnable').checked;
        const selectedChainId = document.getElementById('network').value;
        if (!name || !symbol || !supply) {
          alert('Please fill in all fields');
          return;
        }
        logStatus('Requesting wallet connection...');
        if (!window.ethereum) {
          alert('MetaMask or compatible wallet is required');
          return;
        }
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send('eth_requestAccounts', []);
        const signer = provider.getSigner();
        const address = await signer.getAddress();
        // Check if wallet is on the selected network
        const currentNetwork = await provider.getNetwork();
        if (currentNetwork.chainId.toString() !== selectedChainId) {
          // Attempt to switch to the selected network automatically. MetaMask may throw
          // if the network has not been added yet. We define network parameters
          // for supported testnets here.
          const networkParams = {
            '80002': {
              chainId: '0x13882',
              chainName: 'Polygon Amoy',
              nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
              rpcUrls: ['https://rpc-amoy.polygon.technology'],
              blockExplorerUrls: ['https://amoy.polygonscan.com']
            },
            '11155111': {
              chainId: '0xAA36A7',
              chainName: 'Ethereum Sepolia',
              nativeCurrency: { name: 'Sepolia ETH', symbol: 'SepoliaETH', decimals: 18 },
              rpcUrls: ['https://rpc.sepolia.org'],
              blockExplorerUrls: ['https://sepolia.etherscan.io']
            },
            '44787': {
              chainId: '0xAEEF',
              chainName: 'Celo Alfajores',
              nativeCurrency: { name: 'CELO', symbol: 'CELO', decimals: 18 },
              rpcUrls: ['https://alfajores-forno.celo-testnet.org'],
              blockExplorerUrls: ['https://explorer.celo.org/alfajores']
            }
          };
          logStatus('Warning: Your wallet is connected to chain ID ' + currentNetwork.chainId + '. Attempting to switch to the selected network (' + selectedChainId + ')...');
          const targetParams = networkParams[selectedChainId];
          if (targetParams) {
            try {
              // Request a network switch (wallet must support wallet_switchEthereumChain)
              await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: targetParams.chainId }]
              });
              logStatus('Network switched successfully.');
            } catch (switchError) {
              // 4902 means the chain has not been added to the wallet yet
              if (switchError.code === 4902 || (switchError.data && switchError.data.originalError && switchError.data.originalError.code === 4902)) {
                try {
                  await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [targetParams]
                  });
                  logStatus('Network added and switched automatically.');
                } catch (addError) {
                  console.error(addError);
                  logStatus('Please add the selected network to your wallet manually and try again.');
                }
              } else {
                console.error(switchError);
                logStatus('Automatic network switch failed: ' + (switchError.message || JSON.stringify(switchError)));
              }
            }
          } else {
            logStatus('Selected network parameters not found. Please switch networks in your wallet.');
          }
        }
        // Display the connected network and wallet for transparency
        logStatus('Connected wallet: ' + address + ' on chain ID ' + (await provider.getNetwork()).chainId);
        logStatus('Compiling contract... This may take a moment.');
        const source = getContractSource(mintable, burnable);
        const { abi, bytecode } = await compileContract(source);
        logStatus('Compilation successful. Estimating deployment gas and cost...');
        // Estimate gas for deployment and show approximate cost
        try {
          const factory = new ethers.ContractFactory(abi, '0x' + bytecode, signer);
          const deployTx = await factory.getDeployTransaction(name, symbol, decimals, parseInt(supply));
          const gasEstimate = await provider.estimateGas(deployTx);
          const feeData = await provider.getFeeData();
          // Use maxFeePerGas or gasPrice depending on network support
          const gasPrice = feeData.maxFeePerGas || feeData.gasPrice;
          if (gasPrice) {
            const cost = gasPrice.mul(gasEstimate);
            // Determine symbol for native currency based on selected network
            const currencySymbol = selectedChainId === '80002' ? 'MATIC' : (selectedChainId === '11155111' ? 'ETH' : 'CELO');
            const costFormatted = ethers.utils.formatUnits(cost, 18);
            logStatus('Estimated gas for deployment: ' + gasEstimate.toString() + ' units');
            logStatus('Estimated cost: ~' + costFormatted + ' ' + currencySymbol + ' (may vary)');
          } else {
            logStatus('Gas price unavailable; cost estimate not shown.');
          }
        } catch (e) {
          console.warn('Gas estimate failed:', e);
          logStatus('Unable to estimate gas cost (may still deploy)');
        }
        logStatus('Deploying contract...');
        const factory = new ethers.ContractFactory(abi, '0x' + bytecode, signer);
        // Deploy contract with constructor params
        const contract = await factory.deploy(name, symbol, decimals, parseInt(supply));
        logStatus('Transaction sent. Waiting for confirmation...');
        await contract.deployed();
        logStatus('Token deployed! Contract address: ' + contract.address);
        // Build explorer link based on selected chain
        const explorers = {
          '80002': 'https://amoy.polygonscan.com/address/',
          '11155111': 'https://sepolia.etherscan.io/address/',
          '44787': 'https://explorer.celo.org/alfajores/address/'
        };
        const explorerLink = explorers[selectedChainId] ? explorers[selectedChainId] + contract.address : '';
        // Save references for later actions
        window.deployedContract = contract;
        window.tokenDecimals = decimals;
        window.tokenAllowMint = mintable;
        window.tokenAllowBurn = burnable;
        // Render post-deployment UI
        renderPostDeploy(contract.address, explorerLink, supply);
      } catch (err) {
        console.error(err);
        logStatus('Error: ' + (err.message || JSON.stringify(err)));
      }
    }

    /**
     * Render the post‑deployment user interface.
     * Displays the contract address with an explorer link and, if enabled,
     * provides forms for minting and burning tokens.
     *
     * @param {string} contractAddress The deployed contract address
     * @param {string} explorerLink A link to view the contract on a block explorer (if available)
     * @param {string} initialSupply The initial token supply without decimals
     */
    function renderPostDeploy(contractAddress, explorerLink, initialSupply) {
      const postDiv = document.getElementById('postDeploy');
      postDiv.innerHTML = '';
      // Header
      const header = document.createElement('h3');
      header.className = 'text-xl font-semibold mb-2';
      header.textContent = 'Token Deployed Successfully';
      postDiv.appendChild(header);
      // Contract address and explorer link
      const addressP = document.createElement('p');
      addressP.className = 'mb-2';
      if (explorerLink) {
        addressP.innerHTML = 'Contract Address: <a href="' + explorerLink + '" target="_blank" class="text-indigo-600 underline">' + contractAddress + '</a>';
      } else {
        addressP.textContent = 'Contract Address: ' + contractAddress;
      }
      postDiv.appendChild(addressP);
      // Supply display
      const supplyP = document.createElement('p');
      supplyP.className = 'mb-4';
      supplyP.innerHTML = 'Total Supply: <span id="totalSupplyDisplay">' + initialSupply + '</span> (without decimals)';
      postDiv.appendChild(supplyP);
      // Container for action forms
      const formsContainer = document.createElement('div');
      formsContainer.className = 'space-y-4';
      // Mint form
      if (window.tokenAllowMint) {
        const mintForm = document.createElement('div');
        mintForm.className = 'p-4 bg-gray-50 border rounded';
        mintForm.innerHTML = `
          <h4 class="font-semibold mb-2">Mint Tokens</h4>
          <div class="mb-2">
            <label class="block text-gray-700 text-sm mb-1" for="mintTo">Recipient Address</label>
            <input type="text" id="mintTo" class="w-full border rounded px-3 py-2" placeholder="0x...">
          </div>
          <div class="mb-2">
            <label class="block text-gray-700 text-sm mb-1" for="mintAmount">Amount</label>
            <input type="number" id="mintAmount" class="w-full border rounded px-3 py-2" placeholder="1000">
          </div>
          <button id="mintBtn" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">Mint</button>
        `;
        formsContainer.appendChild(mintForm);
      }
      // Burn form
      if (window.tokenAllowBurn) {
        const burnForm = document.createElement('div');
        burnForm.className = 'p-4 bg-gray-50 border rounded';
        burnForm.innerHTML = `
          <h4 class="font-semibold mb-2">Burn Tokens</h4>
          <div class="mb-2">
            <label class="block text-gray-700 text-sm mb-1" for="burnFrom">Address to Burn From</label>
            <input type="text" id="burnFrom" class="w-full border rounded px-3 py-2" placeholder="0x...">
          </div>
          <div class="mb-2">
            <label class="block text-gray-700 text-sm mb-1" for="burnAmount">Amount</label>
            <input type="number" id="burnAmount" class="w-full border rounded px-3 py-2" placeholder="1000">
          </div>
          <button id="burnBtn" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">Burn</button>
        `;
        formsContainer.appendChild(burnForm);
      }
      // Append forms if any
      if (formsContainer.children.length > 0) {
        postDiv.appendChild(formsContainer);
      }

      // Add balance check form. Always show, regardless of mint/burn options.
      const balanceDiv = document.createElement('div');
      balanceDiv.className = 'p-4 bg-gray-50 border rounded';
      balanceDiv.innerHTML = `
        <h4 class="font-semibold mb-2">Check Token Balance</h4>
        <div class="mb-2">
          <label class="block text-gray-700 text-sm mb-1" for="balanceAddress">Address</label>
          <input type="text" id="balanceAddress" class="w-full border rounded px-3 py-2" placeholder="0x..." />
        </div>
        <button id="balanceBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Check Balance</button>
        <p id="balanceResult" class="mt-2 text-gray-700"></p>
      `;
      postDiv.appendChild(balanceDiv);

      // Event listener for checking balances
      document.getElementById('balanceBtn').addEventListener('click', async (e) => {
        e.preventDefault();
        const addr = document.getElementById('balanceAddress').value.trim();
        const resultP = document.getElementById('balanceResult');
        resultP.textContent = '';
        if (!addr) {
          alert('Please enter an address');
          return;
        }
        try {
          const bal = await window.deployedContract.balanceOf(addr);
          const formatted = ethers.utils.formatUnits(bal, window.tokenDecimals);
          resultP.textContent = 'Balance: ' + formatted;
        } catch (err) {
          console.error(err);
          resultP.textContent = 'Error fetching balance: ' + (err.message || JSON.stringify(err));
        }
      });
      // Attach event listeners for mint/burn
      if (window.tokenAllowMint) {
        document.getElementById('mintBtn').addEventListener('click', async (e) => {
          e.preventDefault();
          const to = document.getElementById('mintTo').value.trim();
          const amount = document.getElementById('mintAmount').value.trim();
          if (!to || !amount) {
            alert('Please fill in recipient and amount');
            return;
          }
          try {
            // amount is provided as whole tokens (without decimals). The contract
            // multiplies by decimals internally, so we pass the raw amount.
            const tx = await window.deployedContract.mint(to, amount);
            logStatus('Mint transaction sent...');
            await tx.wait();
            logStatus('Mint successful');
            // update supply display by reading from contract
            const newTotal = await window.deployedContract.totalSupply();
            const updated = ethers.utils.formatUnits(newTotal, window.tokenDecimals);
            document.getElementById('totalSupplyDisplay').textContent = updated;
          } catch (err) {
            console.error(err);
            logStatus('Mint error: ' + (err.message || JSON.stringify(err)));
          }
        });
      }
      if (window.tokenAllowBurn) {
        document.getElementById('burnBtn').addEventListener('click', async (e) => {
          e.preventDefault();
          const from = document.getElementById('burnFrom').value.trim();
          const amount = document.getElementById('burnAmount').value.trim();
          if (!from || !amount) {
            alert('Please fill in address and amount');
            return;
          }
          try {
            const tx = await window.deployedContract.burn(from, amount);
            logStatus('Burn transaction sent...');
            await tx.wait();
            logStatus('Burn successful');
            // update supply display
            const newTotal = await window.deployedContract.totalSupply();
            const updated = ethers.utils.formatUnits(newTotal, window.tokenDecimals);
            document.getElementById('totalSupplyDisplay').textContent = updated;
          } catch (err) {
            console.error(err);
            logStatus('Burn error: ' + (err.message || JSON.stringify(err)));
          }
        });
      }
    }

    document.getElementById('createBtn').addEventListener('click', createToken);
  </script>
</body>
</html>
